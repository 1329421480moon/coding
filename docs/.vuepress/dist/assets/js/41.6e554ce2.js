(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{267:function(t,a,n){"use strict";n.r(a);var e=n(0),s=Object(e.a)({},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"面向对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面向对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),n("blockquote",[n("p",[t._v("创作不易，转载请注明出处： 后盾人 @ houdurnen.com")])]),t._v(" "),n("h2",{attrs:{id:"历史"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#历史","aria-hidden":"true"}},[t._v("#")]),t._v(" 历史")]),t._v(" "),n("p",[t._v("早期编程由于受电脑硬件限制，程序都是追求效率，而忽略可理解性，扩充性，随着硬件技术的发展，编程越来越重视多人开发，程序员越来越重视程序的可靠性，可扩展性，可维护性，所以刺激了程序语言的发展")]),t._v(" "),n("p",[t._v("面向过程")]),t._v(" "),n("ul",[n("li",[t._v("程序员设计好程序代码流程图，辅助程序设计。优点：用什么功能就编写什么函数    缺点：数据管理上比较混乱 ，主要集中在函数成面上，面向对象把属性和方法进行封装，更好的可重用性和可扩展性")])]),t._v(" "),n("p",[t._v("面向对象")]),t._v(" "),n("ul",[n("li",[t._v("万物皆对象，将构成问题的事务分解到各个对象上，建立对象的目的不是为了完成一个工作，而是为了描述某个事务在解决问题中的行为，更符合人的思维习惯，代码重用性高，可扩展性好")])]),t._v(" "),n("blockquote",[n("p",[t._v("面向对象和面向过程的核心区别是如何分配职责。")])]),t._v(" "),n("h2",{attrs:{id:"类和对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类和对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 类和对象")]),t._v(" "),n("p",[t._v("面向对象是由一系统具有属性和方法的对象构成，对象之间相互交互 ，从而实现业务需求。")]),t._v(" "),n("p",[t._v("属性")]),t._v(" "),n("ul",[n("li",[t._v("在类中定义的变量，即为成员属性，用于描述对象静态特性的数据。如人的姓名，性别，首字母小写")])]),t._v(" "),n("p",[t._v("方法")]),t._v(" "),n("ul",[n("li",[t._v("函数定义在类中即为成员方法，用于描述对象动态特性的操作行为，方法名不区分大小写，不可重名，首字母小写")])]),t._v(" "),n("p",[t._v("对象生命周期")]),t._v(" "),n("ul",[n("li",[t._v("创建后，生命周期开始，当程序结束后或程序员清除对象后即销毁，PHP会自动销毁对象")])]),t._v(" "),n("p",[t._v("类是一种抽象的概念，是具有相同语义定义对象的集合（具有相同属性和方法的集体），使用具体的类是不可行的，只能实例化。拿汽车举例，汽车的设计图纸就是类，汽车是对象。设计中重点是类的创建")]),t._v(" "),n("p",[t._v("类名书写规范")]),t._v(" "),n("ul",[n("li",[t._v("类名首字母大写")]),t._v(" "),n("li",[t._v("一个类定义在一个文件中")])]),t._v(" "),n("h3",{attrs:{id:"this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[t._v("#")]),t._v(" $this")]),t._v(" "),n("p",[t._v("对象中使用 "),n("code",[t._v("$this")]),t._v(" 指针可以访问属性或方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Code\n{\n    protected $len = 5;\n    public function make()\n    {\n        return $this->len . $this->show();\n    }\n    public function show()\n    {\n        return ' : is show';\n    }\n}\necho (new Code)->make();\n")])])]),n("h2",{attrs:{id:"继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),n("p",[t._v("通过使用 "),n("code",[t._v("extends")]),t._v(" 可以继承父类的属性与方法，在PHP中继承是单一的。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Notify\n{\n    public function message()\n    {\n        return 'notify message';\n    }\n}\nclass User extends Notify\n{ }\necho (new User)->message();\n")])])]),n("h3",{attrs:{id:"父类调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#父类调用","aria-hidden":"true"}},[t._v("#")]),t._v(" 父类调用")]),t._v(" "),n("p",[t._v("子类可以使用 "),n("code",[t._v("parent")]),t._v(" 关键字调用父类方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\npublic function message()\n{\n\treturn parent::message();\n}\n...\n")])])]),n("h3",{attrs:{id:"方法重写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法重写","aria-hidden":"true"}},[t._v("#")]),t._v(" 方法重写")]),t._v(" "),n("p",[t._v("子类可以重写父类的方法，除非父类的方法没有使用 "),n("code",[t._v("final")]),t._v(" 修饰。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Notify\n{\n    public function message()\n    {\n        return 'notify message';\n    }\n}\nclass User extends Notify\n{\n    public function message()\n    {\n        return 'user notify';\n    }\n}\necho (new User)->message();\n")])])]),n("h3",{attrs:{id:"禁止重写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#禁止重写","aria-hidden":"true"}},[t._v("#")]),t._v(" 禁止重写")]),t._v(" "),n("p",[t._v("使用final声明的方法，将禁止在子类中重写父类方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public final function message()\n{\n\treturn 'notify message';\n}\n")])])]),n("h2",{attrs:{id:"封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装","aria-hidden":"true"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),n("p",[t._v("public 公有")]),t._v(" "),n("ul",[n("li",[t._v("在类的内部与外部或子类都可以访问，是最开放的权限")])]),t._v(" "),n("p",[t._v("private 私有")]),t._v(" "),n("ul",[n("li",[t._v("定义类的属性和方法，在类的内部可以访问，在类的外部或子类都不可以访问")])]),t._v(" "),n("p",[t._v("protected 受保护")]),t._v(" "),n("ul",[n("li",[t._v("定义类的属性和方法，在类的内部或子类可以访问，类的外部不可以访问")])]),t._v(" "),n("p",[t._v("模块设计")]),t._v(" "),n("ul",[n("li",[t._v("强内聚（功能尽量在类的内部完成），弱耦合（开放尽量少的方法给外部调用）。例：公司销售接项目，具体工作交给公司内部程序员，设计人员，服务器管理人员协同完成")])]),t._v(" "),n("h2",{attrs:{id:"trait"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#trait","aria-hidden":"true"}},[t._v("#")]),t._v(" trait")]),t._v(" "),n("p",[t._v("使用"),n("code",[t._v("trait")]),t._v(" 机制可以变相的使用多重继承。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Alipay\n{\n    use Pay;\n}\nclass WePay\n{\n    use Pay;\n}\n\ntrait Pay\n{\n    public function sn()\n    {\n        return 'ABCDEF';\n    }\n}\necho (new WePay)->sn();\n")])])]),n("p",[t._v("如果本类与 trait 中存在同名的属性和方法时，将使用本类中的属性与方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\nclass WePay\n{\n    use Pay;\n    public function sn()\n    {\n        return __METHOD__;\n    }\n}\n\ntrait Pay\n{\n    public function sn()\n    {\n        return 'ABCDEF';\n    }\n}\n...\n")])])]),n("h3",{attrs:{id:"多个trait"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多个trait","aria-hidden":"true"}},[t._v("#")]),t._v(" 多个trait")]),t._v(" "),n("p",[t._v("可以使用多个 "),n("code",[t._v("trait")]),t._v(" 用逗号连接")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\nuse Pay,Site;\n...\n")])])]),n("h3",{attrs:{id:"解决冲突"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决冲突","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决冲突")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class WePay\n{\n    use Pay, Email {\n    Pay::notify insteadof Email;\n    Email::notify as EmailNotify;\n}\ntrait Pay\n{\n    public function notify()\n    {\n        return __METHOD__;\n    }\n}\ntrait Email\n{\n    public function notify()\n    { \n    \treturn __METHOD__;\n    }\n}\necho (new WePay)->notify();\n\n")])])]),n("p",[n("code",[t._v("Pay::notify insteadof Email")]),t._v(" 表示使用 "),n("code",[t._v("Pay::notify")]),t._v(" 方法替代 "),n("code",[t._v("Email::notify")]),t._v(" 方法。")]),t._v(" "),n("p",[n("code",[t._v("Email::notify as EmailNotify")]),t._v(" 将"),n("code",[t._v("Email:notify")]),t._v(" 别名为 "),n("code",[t._v("EmailNotify")])]),t._v(" "),n("h3",{attrs:{id:"访问控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#访问控制","aria-hidden":"true"}},[t._v("#")]),t._v(" 访问控制")]),t._v(" "),n("p",[t._v("可以为继承的 trait 方法重新定义访问控制")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class WePay\n{\n    use Pay, Email {\n    Pay::notify insteadof Email;\n    Email::notify as protected EmailNotify;\n    ...\n}\n")])])]),n("h3",{attrs:{id:"多重trait"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多重trait","aria-hidden":"true"}},[t._v("#")]),t._v(" 多重trait")]),t._v(" "),n("p",[t._v("可以通过多个"),n("code",[t._v("trait")]),t._v(" 组合来使用。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("trait Notify\n{\n    public function response()\n    {\n        return 'notify response';\n    }\n}\ntrait Pay\n{\n    use Notify;\n}\n\nclass User\n{\n    use Pay;\n}\necho (new User)->response();\n")])])]),n("h3",{attrs:{id:"抽象方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("trait Notify\n{\n    public function response()\n    {\n        return 'notify response' . $this->sn();\n    }\n    abstract protected function sn();\n}\ntrait Pay\n{\n    use Notify;\n}\n\nclass User\n{\n    use Pay;\n    protected function sn()\n    {\n        return 'SN999';\n    }\n}\necho (new User)->response();\n")])])]),n("h3",{attrs:{id:"静态方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 静态方法")]),t._v(" "),n("p",[t._v("在 "),n("code",[t._v("trait")]),t._v(" 中可以使用静态方法、抽象方法、静态属性。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\ntrait Pay\n{\n    public function sn()\n    {\n        return 'ABCDEF';\n    }\n    public static function notify()\n    {\n        return __METHOD__;\n    }\n}\nclass WePay\n{\n    use Pay;\n    ...\n}\necho WePay::notify();\n")])])]),n("h2",{attrs:{id:"static"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#static","aria-hidden":"true"}},[t._v("#")]),t._v(" static")]),t._v(" "),n("p",[t._v("static：")]),t._v(" "),n("ul",[n("li",[t._v("需要一个数据对象只服务于类，即类内部可用，对外不可用时。建对象是极其耗费资源的,因此当一个方法具有比较强的公用性的时候,没有必要为了调用这个方法而重新再生成该类的实例。定义的方法或变量在程序第一次加载时即驻留内存，程序结束释放。")])]),t._v(" "),n("p",[t._v("static变量：")]),t._v(" "),n("ul",[n("li",[t._v("通过static声明的成员变量为静态变量或叫类变量，是该类的公共变量，在第一次使用时即生成，对于该类的所有对象只有一份，是属于类的，不是属于对象的。static变量是属于类而不属于对象，可以在任何地方通地类来访问，是类的全局变量，类创建时即存入内存。对多个对象来说，静态数据成员只存储一处，可以节省内存。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值。")])]),t._v(" "),n("p",[t._v("static方法：")]),t._v(" "),n("ul",[n("li",[t._v("用static声明的方法为静态方法或叫类方法，执行该方法时不会将对象引用传给函数，所以我们不能访问非静态成员，只能访问静态方法或静态变量。只能使用关于类的方式如self   static  parent等。使用时不用生成对象即可执行")])]),t._v(" "),n("h2",{attrs:{id:"类常量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类常量","aria-hidden":"true"}},[t._v("#")]),t._v(" 类常量")]),t._v(" "),n("p",[t._v("使用 "),n("code",[t._v("const")]),t._v(" 来定义类常量，常量使用 "),n("code",[t._v("self::")]),t._v("来调用。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Model implements ArrayAccess, Iterator\n{\n    use ArrayIterator, Relation, Validate, Auto, Filter;\n    //----------自动验证----------\n    //有字段时验证\n    const EXIST_VALIDATE = 1;\n    //值不为空时验证\n    const NOT_EMPTY_VALIDATE = 2;\n    ...\n}\n")])])]),n("h2",{attrs:{id:"this-self-parent"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-self-parent","aria-hidden":"true"}},[t._v("#")]),t._v(" $this self:: parent::")]),t._v(" "),n("p",[t._v("$this")]),t._v(" "),n("ul",[n("li",[t._v("是当前对象的引用， 一般出现在方法里,用于获取类的成员属性，或执行类的成员方法")])]),t._v(" "),n("p",[t._v("self::")]),t._v(" "),n("ul",[n("li",[t._v("对本类的引用 ，用于获取当前类的表态成员属性或静态成员方法self::run()")])]),t._v(" "),n("p",[t._v("parent::")]),t._v(" "),n("ul",[n("li",[t._v("对父类的引用,调用父类的方法或属性。")])]),t._v(" "),n("h2",{attrs:{id:"魔术方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#魔术方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 魔术方法")]),t._v(" "),n("h3",{attrs:{id:"构造方法-析构方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造方法-析构方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 构造方法&析构方法")]),t._v(" "),n("p",[t._v("构造方法__construct()")]),t._v(" "),n("ul",[n("li",[t._v("在创建对象时自动执行，没有返回值，用于执行类的一些初始化工作，如对象属性的初始化工作，构造方法为__construct()。")]),t._v(" "),n("li",[t._v("可以在构造方法中传递参数，用于定义属性，在父类和子类都定义构造方法时，执行子类的构造方法")])]),t._v(" "),n("p",[t._v("析构方法__destruct()：")]),t._v(" "),n("ul",[n("li",[t._v("当所有对象的引用被销毁时执行。")])]),t._v(" "),n("h3",{attrs:{id:"get-与-set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#get-与-set","aria-hidden":"true"}},[t._v("#")]),t._v(" __get 与__set")]),t._v(" "),n("p",[t._v("读取不可访问或不存在的属性时，__get() 会被调用，同理获取不可访问或不存的的属性时会执行 __set() 方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<?php\nabstract class Query\n{\n    abstract protected function record(array $data);\n    public function select()\n    {\n        return $this->record(['name' => '后盾人', 'age' => 33]);\n    }\n}\nclass Model extends Query\n{\n    protected $field = [\n        'name'\n    ];\n\t\tpublic function all(){\n\t\t\t$this->select();\n\t\t\treturn $this->field;\n\t\t}\n    protected function record(array $data)\n    {\n        $this->field = $data;\n    }\n    public function __get($name)\n    {\n        return $this->field[$name] ?? null;\n    }\n    public function __set($name, $value)\n    {\n        $this->field[$name] = $value;\n    }\n}\n\n$user = new Model;\n$user->all();\necho $user->name;\n$user->name = '向军大叔';\necho $user->name;ry\n")])])]),n("p",[t._v("### __isset() 与 __unset()")]),t._v(" "),n("p",[t._v("当使用 isset()函数或者empty()函数 判断属性是否存在或者是否为空的时候会自动触发。")]),t._v(" "),n("p",[t._v("当使用 unset() 函数判断属性时，如果存在__unset() 方法将会执行。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\npublic function __unset($name)\n{\n\tif (!isset($this->field[$name]) || in_array($name, $this->deny)) {\n\t\tthrow new Exception('禁止操作');\n\t}\n}\npublic function __isset($name)\n{\n\treturn isset($this->field[$name]);\n}\n...\n")])])]),n("h2",{attrs:{id:"抽象类-抽象方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽象类-抽象方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 抽象类&抽象方法")]),t._v(" "),n("p",[t._v("具有抽象方法的类为抽象类，抽象方法即为没有内容的空方法，要求子类进行完善内容，抽象类不能实例化，只能继承，通过extends来实现，抽象类中也可以定义普通方法")]),t._v(" "),n("p",[t._v("父类方法执行方式不确定，但子类还都有这个方法")]),t._v(" "),n("ul",[n("li",[t._v("例1：如交通工具类：定义抽象方法控制交通工具运行方式，这样每个交通工具如飞机，汽车都要重写父类方法。如果在父类工具类定义该方法（比如在地上走）没有任何意义，因为每个交通工具都要重写（飞机要重写方法，船要重写方法），所以针对你类方法的不确定性，我们需要抽象方法，实现多态。")])]),t._v(" "),n("p",[t._v("例2：定义动物类，每个动物都有叫声方法，但是表面不同，所以要定义为抽象类，让每种动物类去实现功能。")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("当父类为抽象类时，子类必须重写父类的抽象方法")])]),t._v(" "),n("li",[n("p",[t._v("抽象类里不一定非要写抽象方法，但有抽象方法的类必须定义为抽象类")])]),t._v(" "),n("li",[n("p",[t._v("抽象类必须继承使用")])]),t._v(" "),n("li",[n("p",[t._v("抽象方法不能有主体即{}")])]),t._v(" "),n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<?php\n\nabstract class AbstractClass\n{\n   // 强制要求子类定义这些方法\n\tabstract protected function getValue();\n\n\tabstract protected function prefixValue($prefix);\n\n   // 普通方法（非抽象方法）\n    public function printOut() {\n        print $this->getValue();\n\n    }\n}\n")])])])])]),t._v(" "),n("h2",{attrs:{id:"接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口","aria-hidden":"true"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),n("p",[t._v("接口是一组成员声明方法的集合，包含空的成员方法和常量，空的方法要求继承类去具体实现。成员方法为public，属性为常量。")]),t._v(" "),n("ul",[n("li",[n("ul",[n("li",[t._v("例如：现实中的电脑USB或PCI插槽，插线板等都有接口例子")])])])]),t._v(" "),n("p",[t._v("继承是一级一级层次式，如果某一层出现问题，整个继承就会出现意外。而接口只影响实现接口的类，接口可以在破坏原来的继承基础上对类扩展。接口可以实现多继承。")]),t._v(" "),n("ul",[n("li",[t._v("例：电脑USB接口，规定各个厂商必须构造合适的接口方法，比如手机，数码相机，网银U盾。要让各个厂商写自己的方法如U盾插到USB上他会自动安装网银驱盾，弹出网页，手机装上后可以打开手机里的内容，同时可以充电")])]),t._v(" "),n("p",[t._v("抽象类及普通类都可以实现接口，通过关键字implements")]),t._v(" "),n("p",[t._v("接口与抽象类的区别：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("1 接口只能用implements实现   抽象类用extends继承实现")]),t._v(" "),n("p",[t._v("2 接口没有数据成员，可以定义常量，抽象类可以有")]),t._v(" "),n("p",[t._v("3 接口没有构造函数，抽象类可以定义构造函数")]),t._v(" "),n("p",[t._v("4 接口方法都是public 抽象类方法可以用protected private public来修饰")]),t._v(" "),n("p",[t._v("5 一个类可以实现多个接口，但只能继承一个抽象类")]),t._v(" "),n("p",[t._v("6 接口中不可以有成员方法，抽象类可以有成员方法")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("interface DbInterface {\n    public function connectDb(); //获得连接   参数为表名\n    public function close(); //关闭数据库\n    public function exe($sql); //发送没有返回值的sql\n    public function query($sql); //有返回值的sql\n｝\nclass Db implements DbInterface\n{\n\tpublic function exe($sql){\n\t}\n\tpublic function query($sql{\n\t}\n｝\n")])])])])},[],!1,null,null,null);a.default=s.exports}}]);